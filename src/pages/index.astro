---
import Layout from "../layouts/Layout.astro";

const session = await Astro.locals.auth.validate();
if (!session) return Astro.redirect("/login", 302);
---

<Layout title="Whiteboard the conf">
  <div class="container">
    <header>
      <h1>Whiteboard the conf</h1>
      <p>Grab your custom ticket ðŸ‘€</p>
      <p>User id: {session.user.userId}</p>
      <p>Username: {session.user.username}</p>
    </header>
    <main>
      <canvas width="1080" height="1440"></canvas>
      <fieldset>
        <legend class="sr-only">Color</legend>

        <input
          type="radio"
          id="color-purple"
          name="color"
          value="purple"
          checked
        />
        <label class="sr-only" for="color-purple">Purple</label>

        <input type="radio" id="color-orange" name="color" value="orange" />
        <label class="sr-only" for="color-orange">Orange</label>

        <input type="radio" id="color-pink" name="color" value="pink" />
        <label class="sr-only" for="color-pink">Pink</label>

        <input type="radio" id="color-green" name="color" value="green" />
        <label class="sr-only" for="color-green">Green</label>
      </fieldset>
    </main>
  </div>
</Layout>

<style>
  .container {
    padding-inline: var(--size-2);
    max-width: 80ch;
    margin: auto;
  }

  header {
    padding-block-end: var(--size-4);
  }

  main {
    display: flex;
    gap: var(--size-2);
    align-items: flex-start;
  }

  fieldset {
    background-color: var(--surface-2);
    border-radius: var(--size-4);
    padding: var(--size-2);
    border: var(--size-1) solid var(--surface-1);
    gap: var(--size-2);
    display: flex;
    flex-direction: column;
  }

  canvas {
    background: white;
    max-width: 80%;
    max-height: 80vh;
    border-radius: var(--size-4);
    box-shadow: var(--shadow-5);
  }

  input[name="color"] {
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    width: var(--size-5);
    height: var(--size-5);
    border-radius: 50%;
    background-color: var(--surface-3);
    transition: scale 0.1s ease-in-out;
    position: relative;
  }

  input#color-orange {
    background-color: var(--orange);
  }

  input#color-purple {
    background-color: var(--purple);
  }

  input#color-pink {
    background-color: var(--pink);
  }

  input#color-green {
    background-color: var(--green);
  }

  input[name="color"]:checked {
    scale: 1.1;
  }

  input[name="color"]:checked::before {
    content: "";
    position: absolute;
    inset: -4px;
    border-radius: 100%;
    border: 2px solid var(--surface-4);
  }

  :root {
    --orange-hs: 7, 91%;
    --purple-hs: 263, 100%;
    --pink-hs: 331, 96%;
    --green-hs: 116, 86%;
    --orange: hsl(var(--orange-hs), 50%);
    --purple: hsl(var(--purple-hs), 50%);
    --pink: hsl(var(--pink-hs), 45%);
    --green: hsl(var(--green-hs), 34%);
  }
</style>

<script>
  const colorMap = {
    orange: getCssVar("--orange"),
    purple: getCssVar("--purple"),
    pink: getCssVar("--pink"),
    green: getCssVar("--green"),
  };

  function getCssVar(name: string) {
    return window.getComputedStyle(document.body).getPropertyValue(name);
  }

  const strokeWidth = 25;

  // set colour based on radio input
  const colorInputs = document.querySelectorAll('input[name="color"]')!;
  for (const colorInput of colorInputs) {
    colorInput.addEventListener("change", (evt) => {
      const inputColor = (evt.currentTarget as HTMLInputElement)?.value;
      if (!(inputColor in colorMap)) return;

      const color =
        (colorMap as Record<string, string>)[inputColor] ?? colorMap.purple;

      ctx.strokeStyle = color;
    });
  }

  type Point = { x: number; y: number };

  let drawing = false;
  let latestPoint: Point = { x: 0, y: 0 };

  const canvas = document.querySelector("canvas")!;
  const ctx = canvas.getContext("2d")!;

  ctx.strokeStyle = colorMap.purple;
  ctx.lineWidth = strokeWidth;
  ctx.lineCap = "round";
  ctx.lineJoin = "round";

  function normalizePoint(point: Point): Point {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    console.log(rect.width, rect.height, canvas.width, canvas.height);
    return {
      x: point.x * scaleX,
      y: point.y * scaleY,
    };
  }

  function continueStroke(rawPoint: Point) {
    const point = normalizePoint(rawPoint);

    ctx.beginPath();
    ctx.moveTo(latestPoint.x, latestPoint.y);
    ctx.lineTo(point.x, point.y);
    ctx.stroke();

    latestPoint = point;
  }

  function startStroke(rawPoint: Point) {
    drawing = true;
    latestPoint = normalizePoint(rawPoint);
  }

  const BUTTON = 0b01;
  function isMouseButtonDown(buttons: number) {
    return (buttons & BUTTON) === BUTTON;
  }

  function onMouseMove(evt: MouseEvent) {
    if (!drawing) return;

    continueStroke({ x: evt.offsetX, y: evt.offsetY });
  }

  function onMouseDown(evt: MouseEvent) {
    if (drawing) return;

    evt.preventDefault();
    canvas.addEventListener("mousemove", onMouseMove, false);
    startStroke({ x: evt.offsetX, y: evt.offsetY });
  }

  function onMouseEnter(evt: MouseEvent) {
    if (!isMouseButtonDown(evt.buttons) || drawing) return;

    onMouseDown(evt);
  }

  function onStrokeEnd(evt: MouseEvent) {
    if (!drawing) return;

    drawing = false;
    canvas.removeEventListener("mousemove", onMouseMove, false);
  }

  function getTouchScreenPoint(evt: TouchEvent): Point {
    if (!evt.currentTarget) return { x: 0, y: 0 };
    const rect = (evt.currentTarget as HTMLElement).getBoundingClientRect();
    const touch = evt.targetTouches[0];
    return {
      x: touch.clientX - rect.left,
      y: touch.clientY - rect.top,
    };
  }

  function onTouchStart(evt: TouchEvent) {
    if (drawing) return;
    evt.preventDefault();
    startStroke(getTouchScreenPoint(evt));
  }

  function onTouchMove(evt: TouchEvent) {
    if (!drawing) return;

    continueStroke(getTouchScreenPoint(evt));
  }

  function onTouchEnd(evt: TouchEvent) {
    drawing = false;
  }

  canvas.addEventListener("mousedown", onMouseDown, false);
  canvas.addEventListener("mouseup", onStrokeEnd, false);
  canvas.addEventListener("mouseout", onStrokeEnd, false);
  canvas.addEventListener("mouseenter", onMouseEnter, false);
  canvas.addEventListener("touchstart", onTouchStart, false);
  canvas.addEventListener("touchend", onTouchEnd, false);
  canvas.addEventListener("touchcancel", onTouchEnd, false);
  canvas.addEventListener("touchmove", onTouchMove, false);
</script>

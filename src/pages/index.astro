---
import Layout from "../layouts/Layout.astro";
---

<Layout title="Whiteboard the conf">
  <main>
    <header>
      <h1>Whiteboard the conf</h1>
      <p>Grab your custom ticket ðŸ‘€</p>
    </header>
    <canvas width="1080" height="1440"></canvas>
    <fieldset>
      <legend class="sr-only">Color</legend>

      <input
        type="radio"
        id="color-purple"
        name="color"
        value="purple"
        checked
      />
      <label class="sr-only" for="color-purple">Purple</label>

      <input type="radio" id="color-orange" name="color" value="orange" />
      <label class="sr-only" for="color-orange">Orange</label>

      <input type="radio" id="color-pink" name="color" value="pink" />
      <label class="sr-only" for="color-pink">Pink</label>

      <input type="radio" id="color-green" name="color" value="green" />
      <label class="sr-only" for="color-green">Green</label>
    </fieldset>
  </main>
</Layout>

<style>
  main {
    padding-inline: var(--size-2);
  }

  header {
    padding-block-end: var(--size-4);
  }

  canvas {
    background: white;
    max-width: 80%;
    margin-inline: auto;
    border-radius: var(--size-4);
    box-shadow: var(--shadow-5);
  }

  fieldset {
    display: flex;
    gap: var(--size-1);
    border: none;
  }

  input[name="color"] {
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    width: var(--size-5);
    height: var(--size-5);
    border-radius: 50%;
    background-color: var(--surface-3);
    border: 1px solid var(--surface-1);
    transition: scale 0.1s ease-in-out;
  }

  input#color-orange {
    background-color: var(--orange);
  }

  input#color-purple {
    background-color: var(--purple);
  }

  input#color-pink {
    background-color: var(--pink);
  }

  input#color-green {
    background-color: var(--green);
  }

  input[name="color"]:checked {
    border: 1px solid var(--surface-2);
    scale: 1.1;
  }

  :root {
    --orange-hs: 7, 91%;
    --purple-hs: 263, 100%;
    --pink-hs: 331, 96%;
    --green-hs: 116, 86%;
    --orange: hsl(var(--orange-hs), 50%);
    --purple: hsl(var(--purple-hs), 50%);
    --pink: hsl(var(--pink-hs), 45%);
    --green: hsl(var(--green-hs), 34%);
  }
</style>

<script>
  const colorMap = {
    orange: getComputedStyle(document.documentElement).getPropertyValue(
      "--orange"
    ),
    purple: getComputedStyle(document.documentElement).getPropertyValue(
      "--purple"
    ),
    pink: getComputedStyle(document.documentElement).getPropertyValue("--pink"),
    green: getComputedStyle(document.documentElement).getPropertyValue(
      "--green"
    ),
  };

  const strokeWidth = 25;

  // set colour based on radio input
  const colorInputs = document.querySelectorAll('input[name="color"]')!;
  for (const colorInput of colorInputs) {
    colorInput.addEventListener("change", (evt) => {
      const inputColor = (evt.currentTarget as HTMLInputElement)?.value;
      if (!(inputColor in colorMap)) return;

      const color =
        (colorMap as Record<string, string>)[inputColor] ?? colorMap.purple;

      ctx.strokeStyle = color;
    });
  }

  type Point = { x: number; y: number };

  let drawing = false;
  let latestPoint: Point = { x: 0, y: 0 };

  const canvas = document.querySelector("canvas")!;
  const ctx = canvas.getContext("2d")!;

  ctx.strokeStyle = colorMap.purple;
  ctx.lineWidth = strokeWidth;
  ctx.lineCap = "round";
  ctx.lineJoin = "round";

  function normalizePoint(point: Point): Point {
    const rect = canvas.getBoundingClientRect();
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    console.log(rect.width, rect.height, canvas.width, canvas.height);
    return {
      x: point.x * scaleX,
      y: point.y * scaleY,
    };
  }

  function continueStroke(rawPoint: Point) {
    const point = normalizePoint(rawPoint);

    ctx.beginPath();
    ctx.moveTo(latestPoint.x, latestPoint.y);
    ctx.lineTo(point.x, point.y);
    ctx.stroke();

    latestPoint = point;
  }

  function startStroke(rawPoint: Point) {
    drawing = true;
    latestPoint = normalizePoint(rawPoint);
  }

  const BUTTON = 0b01;
  function isMouseButtonDown(buttons: number) {
    return (buttons & BUTTON) === BUTTON;
  }

  function onMouseMove(evt: MouseEvent) {
    if (!drawing) return;

    continueStroke({ x: evt.offsetX, y: evt.offsetY });
  }

  function onMouseDown(evt: MouseEvent) {
    if (drawing) return;

    evt.preventDefault();
    canvas.addEventListener("mousemove", onMouseMove, false);
    startStroke({ x: evt.offsetX, y: evt.offsetY });
  }

  function onMouseEnter(evt: MouseEvent) {
    if (!isMouseButtonDown(evt.buttons) || drawing) return;

    onMouseDown(evt);
  }

  function onStrokeEnd(evt: MouseEvent) {
    if (!drawing) return;

    drawing = false;
    canvas.removeEventListener("mousemove", onMouseMove, false);
  }

  function getTouchScreenPoint(evt: TouchEvent): Point {
    if (!evt.currentTarget) return { x: 0, y: 0 };
    const rect = (evt.currentTarget as HTMLElement).getBoundingClientRect();
    const touch = evt.targetTouches[0];
    return {
      x: touch.clientX - rect.left,
      y: touch.clientY - rect.top,
    };
  }

  function onTouchStart(evt: TouchEvent) {
    if (drawing) return;
    evt.preventDefault();
    startStroke(getTouchScreenPoint(evt));
  }

  function onTouchMove(evt: TouchEvent) {
    if (!drawing) return;

    continueStroke(getTouchScreenPoint(evt));
  }

  function onTouchEnd(evt: TouchEvent) {
    drawing = false;
  }

  canvas.addEventListener("mousedown", onMouseDown, false);
  canvas.addEventListener("mouseup", onStrokeEnd, false);
  canvas.addEventListener("mouseout", onStrokeEnd, false);
  canvas.addEventListener("mouseenter", onMouseEnter, false);
  canvas.addEventListener("touchstart", onTouchStart, false);
  canvas.addEventListener("touchend", onTouchEnd, false);
  canvas.addEventListener("touchcancel", onTouchEnd, false);
  canvas.addEventListener("touchmove", onTouchMove, false);
</script>
